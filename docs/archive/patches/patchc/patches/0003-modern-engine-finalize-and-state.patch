*** Begin Patch
*** Update File: frontend/src/features/wizard/mode/engines/ModernEngine.tsx
@@
-import React, { useEffect, useMemo, useState } from 'react';
-import { useWizardStoreBridge } from '../bridge/useWizardStoreBridge';
-import { promptFlows } from '../prompts/promptFlows';
-import SmartReview from '../review/SmartReview';
-import StepShell from '../components/StepShell';
-import ProgressBar from '../components/ProgressBar';
-import PrefillCombo from '../components/PrefillCombo';
-import { toCanonicalFor } from '../../../utils/canonicalAdapters';
+import React, { useEffect, useMemo, useState } from 'react';
+import { useWizardStoreBridge } from '../bridge/useWizardStoreBridge';
+import { promptFlows } from '../prompts/promptFlows';
+import SmartReview from '../review/SmartReview';
+import StepShell from '../components/StepShell';
+import ProgressBar from '../components/ProgressBar';
+import PrefillCombo from '../components/PrefillCombo';
+import { toCanonicalFor } from '../../../utils/canonicalAdapters';
+import { useWizardMode } from '../ModeContext';
+
+// Optional: attempt to use existing finalize helper if present.
+// Adjust path if your project uses a different alias.
+let finalizeDeed: null | ((payload: any) => Promise<{ success: boolean; deedId?: string }>) = null;
+try {
+  // @ts-ignore
+  // eslint-disable-next-line @typescript-eslint/no-var-requires
+  const mod = require('@/lib/deeds/finalizeDeed');
+  finalizeDeed = mod?.finalizeDeed || null;
+} catch {}
 
 export default function ModernEngine({ docType }: { docType: string }) {
   const { hydrated, getWizardData, updateFormData } = useWizardStoreBridge();
+  const { mode } = useWizardMode();
   const flow = useMemo(() => promptFlows[docType] || promptFlows['grant-deed'], [docType]);
   const [i, setI] = useState(0);
   const [state, setState] = useState<Record<string, any>>({});
 
   // Initialize from persisted formData (after hydration only)
   useEffect(() => {
     if (!hydrated) return;
     const data = getWizardData();
     const initial = { ...(data.formData || {}) };
     setState(initial);
   }, [hydrated]);
 
   // Keep local changes in sync with persisted store (keyed by mode)
   useEffect(() => {
     if (!hydrated) return;
     updateFormData(state);
   }, [hydrated, state, updateFormData]);
 
   const steps = flow.steps.filter(s => !s.showIf || s.showIf(state));
   const current = steps[i];
   const total = steps.length;
 
   const onNext = async () => {
     if (i < total - 1) {
       setI(i + 1);
     } else {
-      // OLD: location.href to classic finalize
-      if (typeof window !== 'undefined') window.location.href = '/create-deed/finalize';
+      // Final step: build canonical payload and finalize via API/helper.
+      const payload = toCanonicalFor(docType, state);
+      try {
+        let result: { success: boolean; deedId?: string } = { success: false };
+        if (finalizeDeed) {
+          result = await finalizeDeed(payload);
+        } else {
+          const res = await fetch('/api/deeds', {
+            method: 'POST',
+            headers: { 'Content-Type': 'application/json' },
+            body: JSON.stringify(payload),
+          });
+          const json = await res.json();
+          result = { success: !!json?.success, deedId: json?.deedId };
+        }
+        if (result.success) {
+          if (typeof window !== 'undefined') {
+            window.location.href = `/deeds/${result.deedId}/preview?mode=${mode}`;
+          }
+        } else {
+          alert('We could not finalize the deed. Please review and try again.');
+        }
+      } catch (e) {
+        console.error('Finalize failed', e);
+        alert('We could not finalize the deed. Please try again.');
+      }
     }
   };
 
   const onBack = () => setI(Math.max(0, i - 1));
 
   const onChange = (field: string, value: any) => setState(s => ({ ...s, [field]: value }));
 
   const { verifiedData = {}, partners = [] } = getWizardData();
   const ownerCandidates: string[] = Array.from(
     new Set(
       [
         verifiedData?.ownerPrimary,
         verifiedData?.ownerSecondary,
         ...(verifiedData?.owners || []),
       ].filter(Boolean)
     )
   );
 
   return (
     <StepShell>
       <ProgressBar current={i + 1} total={total} />
       {current ? (
         <div className="modern-qna">
           <h1 className="modern-qna__title">{current.title || current.question}</h1>
           <p className="modern-qna__why">{current.why || ''}</p>
 
           {current.type === 'prefill-combo' ? (
             <PrefillCombo
               label={current.label || current.question}
               value={state[current.field] || ''}
               onChange={(v) => onChange(current.field, v)}
               suggestions={current.field === 'grantorName' ? ownerCandidates : []}
               partners={current.field === 'requestedBy' ? partners : []}
               allowNewPartner={current.field === 'requestedBy'}
             />
           ) : (
             <div className="modern-qna__control">
               <input
                 className="modern-input"
                 type="text"
                 value={state[current.field] || ''}
                 onChange={(e) => onChange(current.field, e.target.value)}
                 placeholder={current.placeholder || ''}
               />
             </div>
           )}
 
           <div className="modern-qna__nav">
             <button className="btn btn-secondary" onClick={onBack} disabled={i === 0}>Back</button>
             <button className="btn btn-primary" onClick={onNext}>Next</button>
           </div>
 
           <div className="modern-qna__summary">
             {/* could show micro-summary here */}
           </div>
         </div>
       ) : (
         <SmartReview
           docType={docType}
           state={state}
           onEdit={(field) => {
             const idx = steps.findIndex(s => s.field === field);
             if (idx >= 0) setI(idx);
           }}
           onConfirm={onNext}
         />
       )}
     </StepShell>
   );
 }
*** End Patch
